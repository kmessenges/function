from __future__ import division          
from RpiMotorLib import RpiMotorLib         
from pynput import keyboard

import cv2
import threading
import time
import Adafruit_PCA9685

#초기값 설정
shared_face_coords = None
manual_mode = 1
manual_x = 0
manual_y = 0
manual_a0 = 0
manual_a1 = 0
manual_a2 = 0
coord_lock = threading.Lock()



def display_video():#안면인식 관련 함수1
    while True:
        result, video_frame = video_capture.read()
        if result is False:
            break

        tracked_face_coords = track_last_detected_face(video_frame)
        global shared_face_coords

        with coord_lock:
            shared_face_coords = tracked_face_coords

        if tracked_face_coords is not None:
            x, y, w, h = tracked_face_coords
            cv2.rectangle(video_frame, (x, y), (x + w, y + h), (0, 255, 0), 4)

        cv2.imshow("Tracked Face", video_frame)

        if cv2.waitKey(1) & 0xFF == ord("q"):
              # 카메라 사용 종료
            video_capture.release()
            cv2.destroyAllWindows()
            break


def update_tracked_face(new_face):#안면인식 관련 함수2
    global tracked_face
    if new_face is not None:
        tracked_face = new_face

def track_last_detected_face(vid):#안면인식 관련 함수3
    global tracking_count
    gray_image = cv2.cvtColor(vid, cv2.COLOR_BGR2GRAY)
    faces = face_classifier.detectMultiScale(gray_image, 1.1, 5, minSize=(40, 40))
    
    # 기존 추적 얼굴을 업데이트
    update_tracked_face(tracked_face)
    
    if len(faces) > 0:
        last_detected_face = faces[-1]
        update_tracked_face(last_detected_face)
        tracking_count = tracking_threshold  # 새 얼굴이 감지되면 추적 카운트 초기화
    else:
        if tracking_count > 0:
            tracking_count -= 1
        else:
            update_tracked_face(None)  # 추적 카운트가 0이면 추적 해제

    return tracked_face            

def stepm(turn,range):
    GPIO_pins=(14,15,18)
    direction=20
    step=21
    mymotortest=RpiMotorLib.A4988Nema(direction,step,GPIO_pins,"A4988")
    mymotortest.motor_go(turn,'Full',range,.007,False,.05)
    t=range/200
    time.sleep(t)
        
def motor_control():
    angle0 = 97
    angle1 = 18
    angle2 = 18
    a0 = 97
    a1 = 18
    a2 = 18
    angle2_want = None
    current_state = 4
    next_state = None
    global manual_mode,manual_x, manual_y,manual_a0, manual_a1, manual_a2
    a = 90 -angle2
    b = angle1 - 90
    r = angle0 - 90
    time.sleep(3)
    
    while True:
            
        if manual_mode == 1:
            # 자동모드 실행
            global shared_face_coords
            with coord_lock:
                face_coords = shared_face_coords
            
            if face_coords is not None:
                x, y, w, h = face_coords
                face_coord_x = -frame_w/2 + (x + w/2)
                face_coord_y = -(y + h/2 - frame_h/2)
                
                face_distnace =  w*h
                if face_coord_x >25:
                    stepm(1,3)
                    time.sleep(0.1)
                    print(face_coord_x)
                elif face_coord_x <-125:
                    stepm(0,3)
                    time.sleep(0.1)
                    print(face_coord_x)
                else:
                    stepm(0,0)

                if current_state == 3:
                    if face_distnace < 10000:
                        angle2_want = 45
                        next_state = 4
                    else:
                        pass
                elif current_state == 4:
                    if 4000 > face_distnace:
                        next_state = 6
                        angle2_want = 80
                    elif face_distnace > 16000:
                        next_state = 3
                        angle2_want = 0
                    else:
                        pass

                elif current_state == 6:
                    if face_distnace > 10000:
                        next_state = 4
                        angle2_want = 45
                    else:
                        pass
                        
                else:
                    pass
                
                angle0 = 90-angle2+angle1
                
                if current_state == next_state:
                    pass
                else:
                    #모드 변경을 위한 각도 계산 함수
                    mode_change_with_servo0_ver2(2, angle0, angle1, angle2, angle2_want=45)
                    angle2 = angle2_want
                    angle1 = angle0 + angle2_want-90
                    current_state = next_state

                
                
                if face_coord_y > 30:
                    angle1 = min(135, angle1 +5)
                    
                elif face_coord_y < -30:
                    angle1 = max(0, angle1 - 5)
                    
                else:
                    pass
                
                angle0 = 90-angle2+angle1

                if angle1 <= 0 or angle1 >=135:
                    pass
                else:    
                    set_angle(0, angle0)
                    set_angle(1, angle1)
                    time.sleep(0.05)     

            else: 
                time.sleep(1)
                print("no person")
                
        #수동 모드
        elif manual_mode == 2:
            
            if manual_x == 1:
                stepm(1,10)
                
            elif manual_x == -1:
                stepm(0,10)
                
            if manual_a0 == 1:
                time.sleep(0.1)
                set_angle(0,a0-5)
                a0=a0-5
            elif manual_a0 ==-1:
                time.sleep(0.1)
                set_angle(0,a0+5)
                a0=a0+5
            if manual_a1 == 1:
                time.sleep(0.1)
                set_angle(1,a1+4)
                a1=a1+4
                print(a1)
            elif manual_a1 == -1:
                time.sleep(0.1)
                set_angle(1,a1-4)
                a1=a1-4
                print(a1)
            if manual_a2 == 1:
                time.sleep(0.1)
                set_angle(2,a2-3)
                a2=a2-3

            elif manual_a2 == -1:
                time.sleep(0.1)
                set_angle(2,a2+3)
                a2=a2+3
            
        
        elif manual_mode == 3:
            print('end_program')
            start_position()
            break
        
def on_press(key):
    global manual_mode
    global manual_x,manual_a0, manual_a1, manual_a2
    global manual_y
    try:
        char_key = key.char
        if char_key == 'z':
            manual_mode = 1
            print('Mode auto selected')
        elif char_key == 'x':
            manual_mode = 2
            print('Mode manual selected')
            start_position()
            time.sleep(1)
        elif char_key == 'c':
            manual_mode = 3
        elif char_key == 'q':
            manual_x = 1
        elif char_key == 'a':
            manual_x = -1
        elif char_key == 'w':
            manual_a0 = 1
        elif char_key == 's':
            manual_a0 = -1
        elif char_key == 'e':
            manual_a1 = 1
        elif char_key == 'd':
            manual_a1 = -1
        elif char_key == 'r':
            manual_a2 = 1
        elif char_key == 'f':
            manual_a2 = -1
    except AttributeError:
        pass  
def on_release(key):
    global manual_x, manual_a0, manual_a1, manual_a2
    global manual_y
    manual_x = 0
    manual_y = 0
    manual_a0 = 0
    manual_a1 = 0
    manual_a2 = 0
    pass               
            
               
            
def start_position():
    pwm.set_pwm(0, 0, 420)
    pwm.set_pwm(1, 0, 200)
    pwm.set_pwm(2, 0, 200)
    time.sleep(0.5)

                    
def set_angle(channel, degree):
    pwm_angle = int(150+25/9*degree)
    if pwm_angle >=640:
        pwm_angle = 640
    elif pwm_angle<=150:
        pwm_angle = 150
    pwm.set_pwm(channel, 0, pwm_angle)
    
def mode_change(channel, angle, change, k):
    for i in range(angle-change, angle, k):
        set_angle(channel, i)
        time.sleep(0.05)

def mode_change_with_servo0(channel,angle0, angle1, angle2_current, angle2_next, time1):
    step = int(time1//0.05)
    step_angle = (angle2_next - angle2_current)/step

    angle0_next = 90-angle2_next+angle1
    angle0_step_angle = (angle0_next - angle0)/step

    if angle2_next == 0:
        
        for i in range(1,step+1):
            set_angle(channel, angle2_current+i*step_angle)
            set_angle()
            set_angle()
            time.sleep(0.05)
        
        pass
    else:
        
        for i in range(1,step+1):
            set_angle(channel, angle2_current+i*step_angle)
            set_angle(0, angle0+i*angle0_step_angle)
            time.sleep(0.05)
        

    
def mode_change_with_servo0_ver2(channel,angle0, angle1, angle2_current, angle2_next):
    angle0_next = 90-angle2_next+angle1
    angle1_next = angle0 + angle2_next-90
    
    if angle2_next == 0:
        angle0_next = 90-angle2_next+45
        for i, j  in zip(range(angle2_current, angle2_next, -1 if angle2_current>angle2_next else 1 ),
                range(angle1, angle1_next, -1 if angle1>angle1_next else 1 )):
            set_angle(channel, i)
            set_angle(1, j)
            time.sleep(0.04)
    else:
        for i, j in zip(range(angle2_current, angle2_next, -1 if angle2_current>angle2_next else 1 ),
            range(angle0, angle0_next, -1 if angle0>angle0_next else 1 )):
            set_angle(channel, i)
            set_angle(0, j)
            time.sleep(0.04)
                
    
    


# PWM 초기화
pwm = Adafruit_PCA9685.PCA9685()
pwm.set_pwm_freq(60)

# step



face_classifier = cv2.CascadeClassifier(
    cv2.data.haarcascades + "haarcascade_frontalface_default.xml"
)

frame_w = 480
frame_h = 320
video_capture = cv2.VideoCapture(0)
video_capture.set(cv2.CAP_PROP_FRAME_WIDTH, frame_w)
video_capture.set(cv2.CAP_PROP_FRAME_HEIGHT, frame_h)

tracked_face = None
tracking_threshold = 10  # 연속 추적을 위한 프레임 수
tracking_count = 0

video_thread = threading.Thread(target=display_video)
video_thread.start()

start_position()  # 프로그램 시작 시 중립 위치로 이동

motor_thread = threading.Thread(target=motor_control)
motor_thread.start()

with keyboard.Listener(
        on_press=on_press,
        on_release=on_release) as listener:
    listener.join()
